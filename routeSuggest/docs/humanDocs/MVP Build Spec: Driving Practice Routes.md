## 0. ゴール

ユーザーが入力した

- 出発地点（現在地として扱う。手入力）
- 練習したい／苦手な項目
- 制約（任意）

を元に、以下を一連で実行し、**Googleマップでルートが入力済みの状態のURL**を生成してフロントへ返す。

1. 周辺の練習候補地点（POI）を「検索アセット」に基づき安定的に取得
2. AIが候補から「練習メニューの順番」と「経由地（waypoints）」を決定
3. `origin / destination / waypoints` を **Google Maps Directions URL**（Maps URLs）に変換し、リンク遷移でナビ開始（ユーザーが開始ボタンを押す）できる状態にする

## 1. 全体フロー（処理順）

### Step 1：ユーザー入力（フロント）

ユーザーは以下を入力：

- 出発地点（住所／駅名／ランドマーク）
- 苦手項目（例：バック駐車、右折、路上停止＝路駐に近い練習 など）
- 制約（任意：練習時間、距離短め、など）

フロントはバックエンドにリクエスト送信。

---

### Step 2：バックエンドで出発地点を座標化

**目的**：後続の周辺検索に使う `lat,lng` を確定する

- 入力が住所文字列の場合
    
    → **Geocoding** を使って `lat,lng` に変換
    
- すでに `lat,lng` で入力できるUIならこの工程は省略可

---

### Step 3：検索アセットを選択（固定）

**目的**：検索のブレを防ぎ、安定した候補地点を作る

- バックエンドは `苦手項目` をキーにして、事前に用意した **検索アセット**（テンプレ）を選ぶ
- 検索アセットは次の情報を持つ：

**検索アセットの最低要素（例）**

- `categories`：周辺検索の対象カテゴリ（例：コンビニ、スーパー、ガソリンスタンド等）
- `keywords`：キーワード補助（例：駐車場、パーキング、コインパーキング 等）
- `radius_m`：検索半径（例：1000m〜3000m）
- `max_candidates`：候補上限（例：20〜50）
- `fallback`：候補が少ないときの拡張（例：半径拡大、カテゴリ追加）

> ここは「AIに考えさせない」。MVPではテンプレ選択までを固定化する。
> 

---

### Step 4：周辺POI候補を取得（フィルター検索）

**目的**：練習に使える“場所候補リスト”を作る（AIはここでは創作しない）

- **Places API (New)** で周辺施設を検索
    - `categories` を主軸に検索して候補を集める
    - 足りない場合のみ `keywords` を補助として追加して再検索（fallback）
- 取得した候補をバックエンドで整形／フィルタ
    - 距離で足切り（近すぎ／遠すぎを除外）
    - 重複排除（ほぼ同地点はまとめる）
    - 候補数を `max_candidates` に丸める

この結果を **候補POI一覧**として確定。

---

### Step 5：AIが「最適ルート案（練習順＋経由地）」を決定

**目的**：候補の中から、ユーザーの苦手に合う“練習メニュー”を構成する

AIへの入力は必ず以下に限定する：

- ユーザー入力（苦手項目、制約）
- 候補POI一覧（名称、カテゴリ、座標、距離、可能なら place_id）
- 出発地点座標

AIの出力は必ず以下に限定する：

- `steps`：練習ステップの順番（文章）
- `waypoints`：経由地のリスト（候補POIから選ぶこと）
- `destination`：終点（候補POIから選ぶ、または出発地点に戻す）
- `notes`：注意点（安全配慮の文言）

> 重要：AIは「候補にない場所」を新規に作らない。
> 
> 
> “候補から選ぶ＆並べる”だけにする（ブレ防止）。
> 

---

### Step 6：Googleマップ遷移用URLを生成して確定とする（Routes APIは使わない）

**目的**：ルート入力画面の実装を省略し、「リンクを踏めばGoogleマップでルートが入力済み」を実現する

- バックエンドは、AIが決めた `origin / waypoints / destination` を使って
    
    **Google Maps Directions URL（Maps URLs）** を生成する
    
- 生成するURLは以下の要素を含む（MVP推奨）：
    - `origin`
    - `destination`
    - `waypoints`（複数なら区切り）
    - `travelmode=driving`
    - （任意）`avoid=`（高速回避、有料回避など）
    - （任意）`dir_action=navigate`（ナビ開始寄りで開く）

> 注意：URL生成だけで「開始ボタンを自動で押す」ことはできない。
> 
> 
> ただし、**ルートが入力済みで開く**ので、ユーザーはGoogleマップ側で「開始」を押すだけでよい。
> 

---

### Step 7：フロントに返す

フロントへ返すもの（MVP最小）：

- `google_maps_url`（ルート入力済みの遷移先URL）
- 練習ステップ（`steps`：1→2→3…）
- 注意点（`notes`）

フロントは以下を実施：

- 「Googleマップで開始」ボタンを表示
    - 押下で `google_maps_url` に遷移（別タブ／外部アプリ起動）
- 画面内に手順（steps）と注意点（notes）を表示

---

## 2. 使用するAPI（MVPで使うもの）

### 2.1 Geocoding（任意）

**役割**：住所／駅名 → 緯度経度（lat,lng）

**使うタイミング**：ユーザー入力が座標でない場合のみ

### 2.2 Places API (New)

**役割**：周辺施設検索（候補POIを作る）

**使うタイミング**：検索アセット（カテゴリ＋キーワード）に基づき周辺を検索

### 2.3 Google Maps Directions URL（Maps URLs）

**役割**：Googleマップに遷移して、ルート入力済み状態を作る（APIキー不要）

**使うタイミング**：AIが決めた `origin / waypoints / destination` をURLに埋め込む

> このMVPでは Routes API は使わない（ルート確定はGoogleマップ側に委ねる）。
> 
> 
> 将来的にアプリ内でルート表示・制御をしたくなったら Routes API に戻す。
> 

---

## 3. “揺れを防ぐ”ための実装ルール（必須）

### ルールA：検索はテンプレ化

- 苦手項目 → 検索アセット（カテゴリ／キーワード／半径）を **固定マッピング**で選ぶ
- AIに検索語を作らせない（MVP）

### ルールB：AIは候補からのみ選ぶ

- `waypoints` と `destination` は **候補POI一覧から選ぶ**（座標も候補由来）
- “候補にない新規地点”を出したらバックエンドで却下（将来フォールバックしてもOK）

### ルールC：最終成果物はGoogleマップURL

- MVPの最終成果物は `google_maps_url`
- ルートの表示や「開始」はGoogleマップ側で行う（アプリ側でナビUIを作らない）

---

## 4. MVPで先に決めておく仕様（迷いが出やすいポイント）

### 4.1 終点（destination）の扱い

MVPではどちらかを固定推奨：

- **片道終了**：最後の経由地を終点にする（シンプル）

### 4.2 候補が少ない場合のフォールバック

- 半径を広げる（例：1km → 3km）
- カテゴリを追加（例：コンビニのみ → スーパー/GS追加）
- キーワード検索を追加（例：駐車場、パーキング）

この順番を固定化しておく。→しない

### 4.3 路駐（路上駐車）についての扱い

MVPでは「路上駐車を推奨しない」表現に寄せる：

- 「路上停止に近い操作」は **広い駐車場の端で“寄せて停める”練習**として代替
- POI検索で「路駐スポット」を直接当てに行かない

### 4.4 URL生成の安定性（推奨）

- 可能なら **place_id** を保持し、URL生成に利用できる設計にしておく（同名スポットのブレを減らす）
- waypointsはMVPでは **1〜2個**に抑える（環境差・URL長のリスク低減）

---

## 5. 最終アウトプット（ユーザー体験）

ユーザーは

- アプリ画面で「この順で練習」と手順が見え
- 「Googleマップで開始」ボタンを押すと
- Googleマップが開いてルートが入力済み
- あとはGoogleマップ側で「開始」を押して走る